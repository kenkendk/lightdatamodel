#region Disclaimer / License
// Copyright (C) 2008, Kenneth Skovhede
// http://www.hexad.dk, opensource@hexad.dk
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
// 
#endregion
using System;
using System.Data;
using System.Collections;
using System.Reflection;

namespace System.Data.LightDatamodel
{

	#region " DataClassBase "

	/// <summary>
	/// Base class for non updateable data classes (views)
	/// </summary>
	public abstract class DataCustomClassBase
	{
		internal protected DataFetcher m_dataparent;
	}

	/// <summary>
	/// Base class for all 'database classes'
	/// </summary>
	public abstract class DataClassBase
	{
		internal protected bool m_isdirty = true;
		internal protected IDataFetcher m_dataparent;
		internal protected ObjectStates m_state = ObjectStates.Default;
        internal protected Guid m_guid = Guid.NewGuid();
        internal protected bool m_existsInDB = false;
		public delegate void DataWriteEventHandler(object sender, string propertyname, object oldvalue, object newvalue);
		public event DataWriteEventHandler BeforeDataWrite;
		public event DataWriteEventHandler AfterDataWrite;

        public Guid Guid { get { return m_guid; } }
        public IDataFetcher Dataparent { get { return m_dataparent; } }

        public bool IsPrimaryKeyAutogenerated
        {
            get 
            {
                FieldInfo fi = this.GetType().GetField("m_" + this.UniqueColumn, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.NonPublic);
                if (fi == null)
                    return false;
                MemberModifierEnum m = MemberModifier.CalculateModifier(fi);
                return ((m & MemberModifierEnum.IgnoreWithInsert) == MemberModifierEnum.IgnoreWithInsert)
                    && ((m & MemberModifierEnum.IgnoreWithSelect) != MemberModifierEnum.IgnoreWithSelect);
            }
        }

        internal void SetExistsInDB(bool nv) { m_existsInDB = nv; }
        internal void SetPrimaryKey(object o) 
        { 
                FieldInfo fi = this.GetType().GetField("m_" + this.UniqueColumn, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.NonPublic);
                if (fi == null)
                    return;
                else
                    fi.SetValue(this, o);
        }
        public bool ExistsInDB { get { return m_existsInDB; } }
		public bool IsDirty{get{return m_isdirty;}}
		public ObjectStates ObjectState{get{return m_state;}}

		public abstract string UniqueColumn	{get;}
		public abstract object UniqueValue{get;}
		public void Commit()
		{
            if (m_dataparent as DataFetcher == null)
                throw new Exception("Cannot commit object with a datafetcher, that is not derived from DataFetcher");
            //TODO: If the CommitAll() is not called, then some references may not be correctely persisted to the database
			(m_dataparent as DataFetcher).PopulateDatabase(this);
		}
		public void Update()
		{
            if (m_dataparent as DataFetcher == null)
                throw new Exception("Cannot update object with a datafetcher, that is not derived from DataFetcher");
            (m_dataparent as DataFetcher).UpdateDataClass(this);
		}
		public void Delete()
		{
			if(m_dataparent != null)
			{
				m_dataparent.Remove(this);
			}
		}

		protected void OnBeforeDataWrite(object sender, string propertyname, object oldvalue, object newvalue)
		{
			if(oldvalue == newvalue) return;
			if(BeforeDataWrite != null) BeforeDataWrite(sender, propertyname, oldvalue, newvalue);
		}
	
		protected void OnAfterDataWrite(object sender, string propertyname, object oldvalue, object newvalue)
		{
			if(oldvalue == newvalue) return;
			m_isdirty=true;
			if(AfterDataWrite != null) AfterDataWrite(sender, propertyname, oldvalue, newvalue);
		}

        protected Hashtable m_referenceObjects = new Hashtable();

        /// <summary>
        /// Returns a reference to an object
        /// </summary>
        /// <param name="propertyname">The property that is used to access the object</param>
        /// <param name="idfieldname">The name of the ID value in this instance</param>
        /// <returns>The matching item</returns>
        protected DataClassBase GetReferenceObject(string propertyname, string idfieldname)
        {
            bool found = m_referenceObjects.ContainsKey(propertyname);
            if (!found)
            {
                //Actually, this should be checked for the remote object, not this object
                if (!ExistsInDB && IsPrimaryKeyAutogenerated )
                    //Avoid doing a lookup if the id is not set
                    return null;

                PropertyInfo pi = GetType().GetProperty(propertyname);
                FieldInfo fi = GetType().GetField(idfieldname, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);

                if (fi == null)
                    throw new Exception("Bad config for reference object, field " + idfieldname + " does not exist in class " + GetType().FullName);
                if (pi == null)
                    throw new Exception("Bad config for reference object, property " + propertyname + " does not exist in class " + GetType().FullName);

                DataClassBase c = ((DataClassBase)m_dataparent.GetObjectById(pi.PropertyType, fi.GetValue(this)));
                if (c == null)
                    m_referenceObjects[propertyname] = null;
                else
                    m_referenceObjects[propertyname] = c.Guid;
            }
            
            return m_dataparent.GetObjectByGuid(m_referenceObjects[propertyname]);
        }

        /// <summary>
        /// Sets a reference to an object
        /// </summary>
        /// <param name="propertyname">The property that is used to access the object</param>
        /// <param name="idfieldname">The name of the ID value in this instance</param>
        /// <param name="reversePropertyname">The name of the reverse property or null if there is no reverse property</param>
        /// <param name="value">The value to set the property to</param>
        protected void SetReferenceObject(string propertyname, string idfieldname, string reversePropertyname, DataClassBase value)
        {
            if (value == null)
            {
                if (reversePropertyname != null)
                {
                    DataClassBase revObj = GetReferenceObject(propertyname, idfieldname);
                    if (revObj != null)
                    {
                        PropertyInfo pi = revObj.GetType().GetProperty(reversePropertyname);
                        if (pi.PropertyType.IsAssignableFrom(this.GetType()))
                            pi.SetValue(revObj, null, null);
                        else
                        {
                            object revObjProp = pi.GetValue(revObj, null);
                            if (revObjProp as ICollection != null)
                            {
                                MethodInfo mi = revObjProp.GetType().GetMethod("Remove");
                                if (mi == null)
                                    throw new Exception("Type " + revObjProp.GetType().FullName + " did not have a Remove method");
                                mi.Invoke(revObjProp, new object[] { this });
                            }
                            else
                                throw new Exception("Reverse Property " + reversePropertyname + " on type " + revObj.GetType().FullName + " must be either type " + this.GetType().FullName + " or System.Collections.ICollection");
                        }
                    }
                }

                m_referenceObjects[propertyname] = null;
                m_isdirty = true;
                return;
            }

            if (value.m_dataparent != this.m_dataparent)
                throw new Exception("Cannot mix objects from differenct data contexts");

            m_referenceObjects[propertyname] = value.m_guid;

            FieldInfo fi = GetType().GetField(idfieldname, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);

            if (fi == null)
                throw new Exception("Bad config for reference object, field " + idfieldname + " does not exist in class " + GetType().FullName);
            m_isdirty = true;
            fi.SetValue(this, value.UniqueValue);

            if (reversePropertyname != null)
            {
                PropertyInfo pi = value.GetType().GetProperty(reversePropertyname);
                object revval = pi.GetValue(value, null);

                if (pi.PropertyType.IsAssignableFrom(this.GetType()))
                {
                    if (revval != this)
                        pi.SetValue(value, this, null);
                }
                else
                {
                    if (revval as ICollection != null)
                    {
                        MethodInfo mi = revval.GetType().GetMethod("Contains");
                        if (mi == null)
                            throw new Exception("Type " + revval.GetType().FullName + " did not have a Contains method");
                        bool res = Convert.ToBoolean(mi.Invoke(revval, new object[] { this }));
                        if (!res)
                        {
                            mi = revval.GetType().GetMethod("Add");
                            if (mi == null)
                                throw new Exception("Type " + revval.GetType().FullName + " did not have an Add method");
                            mi.Invoke(revval, new object[] { this });
                        }
                    }
                    else
                        throw new Exception("Reverse Property " + reversePropertyname + " on type " + value.GetType().FullName + " must be either type " + this.GetType().FullName + " or System.Collections.ICollection");
                }
            }
        }
	}

	#endregion

	#region " DataFetcher "

	public delegate void DataConnectionEventHandler(object sender, DataActions action);

	/// <summary>
	/// Interface for all data fetchers
	/// </summary>
	public interface IDataFetcher
	{
		event DataClassBase.DataWriteEventHandler BeforeDataChange;
		event DataClassBase.DataWriteEventHandler AfterDataChange;
		event DataConnectionEventHandler BeforeDataCommit;
		event DataConnectionEventHandler AfterDataCommit;
		event DataConnectionEventHandler AfterDataFetch;

		void CommitAll();

        object[] GetObjectsFromCache(Type type, string filter, params object[] parameters);
        object[] GetObjectsFromCache(Type type, QueryModel.Operation operation);

        object[] GetReferenceObjects(Type type, string reverseProperty, string idProperty, DataClassBase refObj);

        object[] GetObjects(Type type, string filter, params object[] parameters);
		object[] GetObjects(Type type, QueryModel.Operation operation);
		object GetObjectById(Type type, object id);
		void Remove(DataClassBase obj);
		void Add(DataClassBase newobj);
		object CreateObject(Type type);
		IDataProvider Provider { get; }
		Hashtable KnownTypes { get; }
		bool IsDirty { get; }

        //TODO: Should not be public!!!
        /*void PopulateDatabase(DataClassBase item);
        void UpdateDataClass(DataClassBase item);*/

        DataClassBase GetObjectByGuid(object guid);

    }


	/// <summary>
	/// The standard data fetcher, reads from a data provider
	/// </summary>
	public class DataFetcher : IDataFetcher
	{
        protected Hashtable m_guidCache = new Hashtable();
		protected Hashtable m_cache = new Hashtable();
		protected ArrayList m_newobjects = new ArrayList();
		protected ArrayList m_deletedobjects = new ArrayList();
		protected IDataProvider m_provider;
		public event DataClassBase.DataWriteEventHandler BeforeDataChange;
		public event DataClassBase.DataWriteEventHandler AfterDataChange;
		public event DataConnectionEventHandler BeforeDataCommit;
		public event DataConnectionEventHandler AfterDataCommit;
		public event DataConnectionEventHandler AfterDataFetch;
		protected Hashtable m_knownTypes = new Hashtable();

        /*
        
        protected class ReferenceLink
        {
            public DataClassBase CurrentObject;
            public DataClassBase LinkOwner;
            public FieldInfo IDField;
        }
         
        protected Hashtable m_references = new Hashtable();
        
        public void SetCurrentObject(DataClassBase owner, string propertyname, object value)
        {
            if (!m_references.ContainsKey(owner))
                m_references.Add(owner, new Hashtable());
            ((Hashtable)m_references[owner])[propertyname] = value;
        }

        public DataClassBase GetCurrentObject(DataClassBase owner, string propertyname)
        {
            if (!m_references.ContainsKey(owner))
                m_references.Add(owner, new Hashtable());
            Hashtable ht = (Hashtable)m_references[owner];
            if (!ht.ContainsKey(propertyname))
                return null;
            else
                return ht[propertyname];
        }
        
        */

		public bool IsDirty 
		{
			get 
			{
				if ((m_newobjects.Count > 0) || (m_deletedobjects.Count > 0))
					return true;

				foreach(Hashtable table in m_cache.Values)
					foreach(DataClassBase obj in table.Values)
						if(obj.IsDirty) 
							return true;
				
				return false;
			}
		}

		public DataFetcher(IDataProvider provider)
		{
			m_provider = provider;
		}

		public Hashtable KnownTypes { get { return m_knownTypes; } }

		public virtual void CommitAll()
		{
			Guid transactionID = Guid.NewGuid();
			bool inTransaction = false;

			m_provider.BeginTransaction(transactionID);
			inTransaction = true;

			try
			{
				ArrayList updated = new ArrayList();
				foreach(Hashtable table in m_cache.Values)
					foreach(DataClassBase obj in table.Values)
						if(obj.IsDirty)
							updated.Add(obj);

				ArrayList added = new ArrayList(m_newobjects);
				ArrayList removed = new ArrayList(m_deletedobjects);

				CommitEvaluator.CommitAll(added, removed, updated);

				m_provider.CommitTransaction(transactionID);
				m_newobjects = new ArrayList();
				m_deletedobjects = new ArrayList();
				inTransaction = false;
			}
			finally
			{
				if (inTransaction)
					m_provider.RollbackTransaction(transactionID);
			}
		}

		protected virtual void HookObject(DataClassBase obj)
		{
			string tablename = obj.GetType().Name;
			obj.BeforeDataWrite += new System.Data.LightDatamodel.DataClassBase.DataWriteEventHandler(obj_BeforeDataWrite);
			obj.AfterDataWrite += new System.Data.LightDatamodel.DataClassBase.DataWriteEventHandler(obj_AfterDataWrite);
			if(!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());
            if (!obj.IsPrimaryKeyAutogenerated || obj.ExistsInDB)
            {
                if (((Hashtable)m_cache[tablename]).ContainsKey(obj.UniqueValue)) ((Hashtable)m_cache[tablename]).Remove(obj.UniqueValue);
                ((Hashtable)m_cache[tablename]).Add(obj.UniqueValue, obj);
            }
            m_guidCache[obj.m_guid] = obj;
		}

		protected virtual bool IsDataClassBase(Type type)
		{
			do
			{
				if(type == typeof(DataClassBase)) return true;
				type = type.BaseType;
			}while(type != null);
			return false;
		}

		protected virtual bool IsDataCustomClassBase(Type type)
		{
			do
			{
				if(type == typeof(DataCustomClassBase)) return true;
				type = type.BaseType;
			}while(type != null);
			return false;
		}

		public IDataProvider Provider { get { return m_provider; } }

		/// <summary>
		/// This will load a list of arbitary objects
		/// If the given object is a DataClassBase it will be hooked into the DataFetcher
		/// DataCustomClassBase will also have it's values filled
		/// All others will just be filled with the data
		/// </summary>
		/// <param name="type">The type of objects to load</param>
		/// <param name="filter">The filter used to select objects</param>
		/// <returns>All matching objects</returns>
		public virtual object[] GetObjects(Type type, string filter, params object[] parameters)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);
			
			//This ensures that we always query the memory
			return GetObjects(type, QueryModel.Parser.ParseQuery(filter, parameters));

			/*Data[][] data = m_provider.SelectRows(tablename, filter);
			return InsertObjectsInCache(type, data);*/
		}

        /// <summary>
        /// Will return all objects where the IdProperty is set to the referenceObject
        /// </summary>
        /// <param name="type">The type of the objects to load</param>
        /// <param name="properyName">The name of the reference property</param>
        /// <param name="idProperty">The name of the IdProperty on the type</param>
        /// <param name="refObj">The reference object to match</param>
        /// <returns></returns>
        public virtual object[] GetReferenceObjects(Type type, string properyName, string idProperty, DataClassBase refObj)
        {
            string tablename = type.Name;
            if (!m_knownTypes.ContainsKey(tablename))
                m_knownTypes.Add(tablename, type);

            if (refObj.ExistsInDB)
            {
                Data[][] data = m_provider.SelectRows(tablename, idProperty + "=?", new object[] { refObj.UniqueValue });
                if (!refObj.IsDirty)
                    return InsertObjectsInCache(type, data);

                InsertObjectsInCache(type, data);
            }

            return GetObjectsFromCache(type, properyName + ".Guid=?" + refObj.Guid);
        }

		/// <summary>
		/// This will load a list of arbitary objects
		/// If the given object is a DataClassBase it will be hook into the DataFetcher
		/// DataCustomClassBase will also have it's values filled
		/// All others will just be filled with the data
		/// </summary>
		/// <param name="type">The type of objects to load</param>
		/// <param name="operation">The filter used to select objects</param>
		/// <returns>All matching objects</returns>
		public virtual object[] GetObjects(Type type, QueryModel.Operation operation)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);

#if REDUCE_DB_LOAD
			QueryModel.Parameter[] p = new QueryModel.Parameter[((Hashtable)m_cache[tablename]).Count + 1];
			int i = 1;
			foreach(object o in ((Hashtable)m_cache[tablename]).Keys)
				p[i++] = new QueryModel.Parameter(o, false);

			p[0] = new QueryModel.Parameter(((DataClassBase)Activator.CreateInstance(type)).UniqueColumn, true);
			QueryModel.Operation op = new QueryModel.Operation(QueryModel.Operators.In, p);
			op = new QueryModel.Operation(QueryModel.Operators.Not, op);
			op = new QueryModel.Operation(QueryModel.Operators.And, new QueryModel.OperationOrParameter[] {op, operation});

			Data[][] data = m_provider.SelectRows(tablename, op);
			InsertObjectsInCache(type, data);
			return operation.EvaluateList(((SortedList)m_tables[tablename]).Values);
#else
			Data[][] data = m_provider.SelectRows(tablename, operation);
			//Re-evaluate condition on the returned objects + objects modified in memory
            InsertObjectsInCache(type, data);
            return GetObjectsFromCache(type, operation);
#endif
		}

        /// <summary>
        /// Discards all changes from the object, and removes it from the internal cache
        /// </summary>
        /// <param name="obj">The object to discard</param>
        public void DiscardObject(DataClassBase obj)
        {
			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());

			if(!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());

            if (m_guidCache.ContainsKey(obj.Guid))
                m_guidCache.Remove(obj.Guid);
            
            if (obj.ExistsInDB)
                if (((Hashtable)m_cache[tablename]).ContainsKey(obj.UniqueValue))
                    ((Hashtable)m_cache[tablename]).Remove(obj.UniqueValue);
        }

        /// <summary>
        /// Reads objects from the cache, will not communicate with the database
        /// </summary>
        /// <param name="type"></param>
        /// <param name="filter"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public object[] GetObjectsFromCache(Type type, string filter, params object[] parameters)
        {
            return GetObjectsFromCache(type, QueryModel.Parser.ParseQuery(filter, parameters));
        }

        /// <summary>
        /// Reads objects from the cache, will not communicate with the database
        /// </summary>
        /// <param name="type"></param>
        /// <param name="query"></param>
        /// <returns></returns>
        public object[] GetObjectsFromCache(Type type, QueryModel.Operation query)
        {
            string tablename = type.Name;
            if (!m_knownTypes.ContainsKey(tablename))
                m_knownTypes.Add(tablename, type);

            if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());

            ArrayList allItems = new ArrayList();
            if (m_provider as NestedDataProvider != null)
            {
                Data[][] d = ((NestedDataProvider)m_provider).SelectRowsFromCache(tablename, query);
                if (d != null)
                    InsertObjectsInCache(type, d);
            }
            allItems.AddRange(((Hashtable)m_cache[tablename]).Values);
            foreach (DataClassBase o in m_newobjects)
                if (o.GetType().IsAssignableFrom(type))
                    allItems.Add(o);

            return query.EvaluateList(allItems);
        }

        
		private object[] InsertObjectsInCache(Type type, Data[][] data)
		{
			object[] ret = new object[data.Length];

			if(IsDataClassBase(type))
			{
				string tablename = type.Name;
				if (!m_knownTypes.ContainsKey(tablename))
					m_knownTypes.Add(tablename, type);
				if(!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());

                QueryModel.Operation opdeleted = QueryModel.Parser.ParseQuery("GetType.FullName = ? AND UniqueValue = ?", type.FullName);

                ArrayList res = new ArrayList();

				for(int i = 0; i < ret.Length; i++)
				{
					DataClassBase newobj = (DataClassBase)Activator.CreateInstance(type);
					PopulateDataClass(newobj, data[i]);
					if(!((Hashtable)m_cache[tablename]).ContainsKey(newobj.UniqueValue))
					{
                        if (opdeleted.EvaluateList(m_deletedobjects, newobj.UniqueValue).Length > 0)
                            continue;

						newobj.m_dataparent = this;
						newobj.m_state = ObjectStates.Default;
						newobj.m_isdirty = false;
                        if (m_provider as NestedDataProvider == null)
                            newobj.m_existsInDB = true;
						res.Add(newobj);

						//add to cache
						HookObject(newobj);
						if(AfterDataFetch != null) AfterDataFetch(newobj, DataActions.Fetch);
					}
					else
						res.Add(((Hashtable)m_cache[tablename])[newobj.UniqueValue]);
				}
                ret = res.ToArray();
            }
			else if(IsDataCustomClassBase(type))
			{
				for(int i = 0; i < ret.Length; i++)
				{
					DataCustomClassBase newobj = (DataCustomClassBase)Activator.CreateInstance(type);
					PopulateDataClass(newobj, data[i]);
					newobj.m_dataparent = this;
					ret[i] = newobj;
				}
			}
			else
			{
				for(int i = 0; i < ret.Length; i++)
				{
					object newobj = Activator.CreateInstance(type);
					PopulateDataClass(newobj, data[i]);
					ret[i] = newobj;
				}
			}

			return ret;
		}

		/// <summary>
		/// Marks an object for deletion
		/// </summary>
		/// <param name="id">ID of the item</param>
		/// <param name="type">Type of the item to delete</param>
		public void DeleteObject(object id, Type type)
		{
			DataClassBase tobedeleted = (DataClassBase)GetObjectById(type, id);
			if(tobedeleted != null) Remove(tobedeleted);
		}

        /// <summary>
        /// Gets an object by its Guid
        /// </summary>
        /// <param name="key">The key to look for, must be of type Guid</param>
        /// <returns>The item matching the Guid, or null</returns>
        public virtual DataClassBase GetObjectByGuid(object key)
        {
            if (key == null || key.GetType() != typeof(Guid))
                return null;

            if (m_guidCache.ContainsKey(key))
                return (DataClassBase)m_guidCache[key];
            else if (m_provider as NestedDataProvider != null)
            {
                DataClassBase o = ((NestedDataProvider)m_provider).BaseFetcher.GetObjectByGuid(key);
                if (o == null)
                    return null;
                Data[] data = (m_provider as NestedDataProvider).FromObjectToData(o);
                return (DataClassBase)(InsertObjectsInCache(o.GetType(), new Data[][] { data })[0]);
            }
            else
                return null;
        }

		/// <summary>
		/// This will load the given DataClassBase object
		/// </summary>
		/// <param name="type"></param>
		/// <param name="id"></param>
		/// <returns></returns>
		public virtual object GetObjectById(Type type, object id)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);

			if(!IsDataClassBase(type)) throw new Exception("This object cannot be fetched by primary key. Use GetObjects instead");

			if(!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());
			if(!((Hashtable)m_cache[tablename]).ContainsKey(id))
			{
				//Fetch From Data source
                DataClassBase newobj = (DataClassBase)Activator.CreateInstance(type);
                Data[] data = m_provider.SelectRow(tablename, newobj.UniqueColumn, id);
                if (data == null) return null;
                InsertObjectsInCache(type, new Data[][] { data });
			}
					
			return ((Hashtable)m_cache[tablename])[id];
		}

		public virtual void Remove(DataClassBase obj)
		{
			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());

			if(obj.ObjectState == ObjectStates.New)
			{
				m_newobjects.Remove(obj);
                m_guidCache.Remove(obj.m_guid);
			}
			else
			{
				if(!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());
				((Hashtable)m_cache[tablename]).Remove(obj.UniqueValue);
				m_deletedobjects.Add(obj);
				obj.m_state = ObjectStates.Deleted;
			}
		}

		public virtual void Add(DataClassBase newobj)
		{
			newobj.m_dataparent = this;
			newobj.m_state = ObjectStates.New;
			m_newobjects.Add(newobj);
            newobj.SetExistsInDB(false);

            string tablename = newobj.GetType().Name;
            if (!m_knownTypes.ContainsKey(tablename))
                m_knownTypes.Add(tablename, newobj.GetType());
            m_guidCache.Add(newobj.m_guid, newobj);
		}

        internal void ReRegisterObjectGuid(Guid oldkey, DataClassBase obj)
        {
            m_guidCache.Remove(oldkey);
            m_guidCache[obj.m_guid] = obj;
        }

		public virtual object CreateObject(Type type)
		{
			DataClassBase newobj = (DataClassBase)Activator.CreateInstance(type);
			Add(newobj);
			return newobj;
		}

		protected internal virtual void UpdateDataClass(DataClassBase obj)
		{
			if(obj.ObjectState == ObjectStates.Deleted) return;
            if (obj.IsPrimaryKeyAutogenerated && !obj.ExistsInDB)
            {
                obj.m_dataparent = this;
                obj.m_state = ObjectStates.Default;
                obj.m_isdirty = false;
                return;
            }

			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());
			Data[] data = m_provider.SelectRow(tablename, obj.UniqueColumn, obj.UniqueValue);
			if(data == null) throw new Exception("Row (" + obj.UniqueValue + ") from table \"" + tablename + "\" can't be fetched");
			PopulateDataClass(obj, data);
			obj.m_dataparent = this;
			obj.m_state = ObjectStates.Default;
			obj.m_isdirty = false;
			if(AfterDataFetch != null) AfterDataFetch(obj, DataActions.Fetch);
		}

		protected internal virtual void PopulateDatabase(DataClassBase obj)
		{
			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());

			//get private fields
			FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
			ArrayList fieldList = new ArrayList();
			for(int i = 0; i < fields.Length; i++)
			{
				Data d = new Data(fields[i].Name, fields[i].GetValue(obj), fields[i].FieldType);
                if (d.Name.StartsWith("m_"))
                    d.Name = d.Name.Substring(2);
				MemberModifierEnum m = MemberModifier.CalculateModifier(fields[i]);
				if (obj.ObjectState == ObjectStates.New) 
				{
					if ((m & MemberModifierEnum.IgnoreWithInsert) != MemberModifierEnum.IgnoreWithInsert)
						fieldList.Add(d);
				}
				else if (obj.ObjectState == ObjectStates.Default) 
				{
					if ((m & MemberModifierEnum.IgnoreWithUpdate) != MemberModifierEnum.IgnoreWithUpdate)
						fieldList.Add(d);
				}
				else
					fieldList.Add(d);
			}

            if (obj as DataClassBase != null)
                foreach (string s in new string[] { "m_guid", "m_existsInDB", "m_referenceObjects" })
                {
                    FieldInfo bfi = typeof(DataClassBase).GetField(s, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                    if (bfi != null)
                        fieldList.Add(new Data(bfi.Name, bfi.GetValue(obj), null));
                    //All 'special' values are tagged with type == null
                }


			Data[] data = (Data[])fieldList.ToArray(typeof(Data));

			//sql
			if(obj.ObjectState == ObjectStates.Default)
			{
				if(BeforeDataCommit != null) BeforeDataCommit(obj, DataActions.Update);
                if (obj.ExistsInDB || !obj.IsPrimaryKeyAutogenerated)
				    m_provider.UpdateRow(tablename, obj.UniqueColumn, obj.UniqueValue, data);
				if(AfterDataCommit != null) AfterDataCommit(obj, DataActions.Update);
			}
			else if(obj.ObjectState == ObjectStates.New)
			{
				if(BeforeDataCommit != null) BeforeDataCommit(obj, DataActions.Insert);
				m_provider.InsertRow(tablename, data);
				m_newobjects.Remove(obj);

                if (m_provider as NestedDataProvider == null)
                {
                    obj.SetExistsInDB(true);
                    if (obj.IsPrimaryKeyAutogenerated)
                        obj.SetPrimaryKey(m_provider.GetLastAutogeneratedValue(tablename));
                }

                if (obj.ExistsInDB || !obj.IsPrimaryKeyAutogenerated)
                {
                    if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());
                    ((Hashtable)m_cache[tablename]).Add(obj.UniqueValue, obj);
                }
				if(AfterDataCommit != null) AfterDataCommit(obj, DataActions.Insert);
			}
			else if(obj.ObjectState == ObjectStates.Deleted)
			{
				if(BeforeDataCommit != null) BeforeDataCommit(obj, DataActions.Delete);
				m_provider.DeleteRow(tablename, obj.UniqueColumn, obj.UniqueValue);
				m_deletedobjects.Remove(obj);
                m_guidCache.Remove(obj.m_guid);
                if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new Hashtable());
                ((Hashtable)m_cache[tablename]).Remove(obj.UniqueValue);
				if(AfterDataCommit != null) AfterDataCommit(obj, DataActions.Delete);
			}

            //Try to read data back from database
            obj.Update();

		}

		/// <summary>
		/// This will insert the given data into an arbitary object (the private variables)
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="data"></param>
		protected internal virtual void PopulateDataClass(object obj, Data[] data)
		{
			for(int i = 0; i < data.Length; i++)
			{
                bool isDataClassBase = obj as DataClassBase != null;
				try
				{
                    if (data[i].Type != null)
                    {
                        FieldInfo field = obj.GetType().GetField("m_" + data[i].Name, BindingFlags.Instance | BindingFlags.NonPublic);
                        if (field != null)
                        {
                            MemberModifierEnum m = MemberModifier.CalculateModifier(field);
                            if ((m & MemberModifierEnum.IgnoreWithSelect) != MemberModifierEnum.IgnoreWithSelect)
                            {
                                if (data[i].Value != DBNull.Value)
                                    field.SetValue(obj, data[i].Value);
                                else
                                    field.SetValue(obj, m_provider.GetNullValue(data[i].Type));
                            }
                        }
                    }
                    else if (isDataClassBase)
                    {
                        FieldInfo bfi = typeof(DataClassBase).GetField(data[i].Name, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                        if (bfi != null)
                            bfi.SetValue(obj, data[i].Value);
                     }
                }
				catch(Exception ex)
				{
					throw new Exception("Couldn't set field\nError: " + ex.Message);
				}
			}
		}

		protected virtual void obj_BeforeDataWrite(object sender, string propertyname, object oldvalue, object newvalue)
		{
			if(BeforeDataChange != null) BeforeDataChange(sender, propertyname, oldvalue, newvalue);
		}

		protected virtual void obj_AfterDataWrite(object sender, string propertyname, object oldvalue, object newvalue)
		{
			if(AfterDataChange != null) AfterDataChange(sender, propertyname, oldvalue, newvalue);
		}
	}

	/// <summary>
	/// Nested data fetcher, shorthand class for:
	/// = new DataFetcher(new NestedDataProvider(basefetcher))
	/// </summary>
	public class NestedDataFetcher : DataFetcher
	{
		public NestedDataFetcher(IDataFetcher basefetcher)
			: base(new NestedDataProvider(basefetcher))
		{
            ((NestedDataProvider)m_provider).KnownTypes = this.KnownTypes;
		}
	}

	/// <summary>
	/// Nested data provider, reads data from an existing DataFetcher.
	/// Use this class to perform in-memory transactions that can be easily undone.
	/// </summary>
	public class NestedDataProvider : IDataProvider
	{
		public NestedDataProvider(IDataFetcher parent)
		{
			m_baseFetcher = parent;
			m_provider = m_baseFetcher.Provider;
		}


		protected IDataFetcher m_baseFetcher;
		protected IDataProvider m_provider;
        protected Hashtable m_types = null;
        public Hashtable KnownTypes { get { return m_types; } set { m_types = value; } }

        public IDataFetcher BaseFetcher { get { return m_baseFetcher; } }

		#region IDataProvider Members

		public void DeleteRow(string tablename, string primarycolumnname, object primaryvalue)
		{
            m_baseFetcher.Remove((DataClassBase)m_baseFetcher.GetObjectById((System.Type)KnownTypes[tablename], primaryvalue));
		}

		public Data[] SelectRow(string tablename, string primarycolumnname, object primaryvalue)
		{
            DataClassBase obj = (DataClassBase)m_baseFetcher.GetObjectById((System.Type)KnownTypes[tablename], primaryvalue);
            if (obj == null)
                return null;
            return FromObjectToData(obj);
		}

		internal Data[] FromObjectToData(object o)
		{
            FieldInfo[] fi = o.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            ArrayList fields = new ArrayList();

			for(int i = 0; i < fi.Length; i++)
				if (fi[i].Name.StartsWith("m_"))
					fields.Add(new Data(fi[i].Name.Substring(2), fi[i].GetValue(o), fi[i].ReflectedType));
				else
					fields.Add(new Data(fi[i].Name, fi[i].GetValue(o), fi[i].ReflectedType));

            if (o as DataClassBase != null)
                foreach (string s in new string[] { "m_guid", "m_existsInDB", "m_referenceObjects" } )
                {
                    FieldInfo bfi = typeof(DataClassBase).GetField(s, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                    if (bfi != null)
                        fields.Add(new Data(bfi.Name, bfi.GetValue(o), null));
                        //All 'special' values are tagged with type == null
                }
            
			return (Data[])fields.ToArray(typeof(Data));
		}

		internal void UpdateObject(object o, Data[] d)
		{
            bool isDataClassBase = o as DataClassBase != null;

			for(int i = 0; i < d.Length; i++)
			{
                FieldInfo fi = o.GetType().GetField("m_" + d[i].Name, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                if (fi != null && d[i].Type != null)
                {
                    if (d[i].Value == null)
                        fi.SetValue(o, null);
                    else
                        fi.SetValue(o, Convert.ChangeType(d[i].Value, fi.FieldType));
                }
                //We tag the Guid property with an invalid type, to avoid potential conflicts with similarly named properties
                else if (d[i].Type == null && isDataClassBase)
                {
                    FieldInfo bfi = typeof(DataClassBase).GetField(d[i].Name, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                    if (bfi != null)
                        bfi.SetValue(o, d[i].Value);
                }
			}
		}

        public Data[][] SelectRowsFromCache(string tablename, QueryModel.Operation operation)
        {
            object[] items = m_baseFetcher.GetObjectsFromCache((Type)KnownTypes[tablename], operation);
            Data[][] v = new Data[items.Length][];
            for (int i = 0; i < items.Length; i++)
                v[i] = FromObjectToData(items[i]);
            return v;
        }

		public Data[][] SelectRows(string tablename, QueryModel.Operation operation)
		{
            object[] items = m_baseFetcher.GetObjects((Type)KnownTypes[tablename], operation);
			Data[][] v = new Data[items.Length][];
			for(int i = 0; i < items.Length; i++)
				v[i] = FromObjectToData(items[i]);
			return v;
		}

		public Data[][] SelectRows(string tablename, string filter)
		{
			return SelectRows(tablename, filter, null);
		}

		public Data[][] SelectRows(string tablename, string filter, object[] values)
		{
			return SelectRows(tablename, QueryModel.Parser.ParseQuery(filter, values));
		}

		public void UpdateRow(string tablename, string primarycolumnname, object primaryvalue, params Data[] values)
		{
            DataClassBase obj = (DataClassBase)m_baseFetcher.GetObjectById((Type)KnownTypes[tablename], primaryvalue);
            obj.m_isdirty = true;
            UpdateObject(obj, values);
		}

		public void InsertRow(string tablename, params Data[] values)
		{
            DataClassBase o = (DataClassBase)m_baseFetcher.CreateObject((Type)KnownTypes[tablename]);
            Guid oldkey = o.m_guid;
            UpdateObject(o, values);
            if (m_baseFetcher as IDataFetcher == null)
                throw new Exception("Nested provider can only commit to fetcher derived from DataFetcher");
            ((DataFetcher)m_baseFetcher).ReRegisterObjectGuid(oldkey, o);
		}

		public string GetPrimaryKey(string tablename)
		{
			return m_provider.GetPrimaryKey(tablename);
		}

		public string[] GetTablenames()
		{
			return m_provider.GetTablenames();
		}

		public Data[] GetStructure(string sql)
		{
			return m_provider.GetStructure(sql);
		}

		public Data[] GetTableStructure(string tablename)
		{
			return m_provider.GetTableStructure(tablename);
		}

		public void Close()
		{
		}

		public string ConnectionString
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public object GetNullValue(Type type)
		{
			return m_provider.GetNullValue(type);
		}

		public void BeginTransaction(Guid id)
		{
			//TODO: Implement these...	
		}

		public void CommitTransaction(Guid id)
		{
			//TODO: Implement these...	
		}

		public void RollbackTransaction(Guid id)
		{
			//TODO: Implement these...	
		}

        public object GetLastAutogeneratedValue(string tablename)
        {
            return null;
        }


		#endregion

	}


	#endregion

    #region " SyncCollectionBase "
    public class SyncCollectionBase
    {
        protected System.Collections.ArrayList m_baseList = new System.Collections.ArrayList();
        protected System.Reflection.PropertyInfo m_reverseProperty = null;
        protected object m_owner = null;
        protected Type m_baseType = null;

        public SyncCollectionBase() { }

        public SyncCollectionBase(Type baseType, object owner, string reversePropertyname, string reversePropertyID)
        {
            if (owner == null)
                throw new System.ArgumentNullException("owner");
            if (baseType == null)
                throw new System.ArgumentNullException("baseType");
            m_owner = owner;
            m_baseType = baseType;
            m_reverseProperty = m_baseType.GetProperty(reversePropertyname);
            if (m_reverseProperty == null)
                throw new System.Exception("Class " + m_baseType.FullName + " does not contain the property " + reversePropertyname);

            System.Data.LightDatamodel.DataClassBase db = owner as System.Data.LightDatamodel.DataClassBase;
            if (db != null)
            {
                if (db.ExistsInDB)
                    db.Dataparent.GetObjects(m_baseType, reversePropertyID + "=?", db.UniqueValue);

                m_baseList.AddRange(db.Dataparent.GetObjectsFromCache(m_baseType, reversePropertyname + ".Guid=?", db.Guid));
            }
        }

        protected void UpdateReverse(object item, bool remove)
        {
            if (m_reverseProperty != null && m_owner != null)
				if (m_reverseProperty.PropertyType.IsAssignableFrom(m_owner.GetType()))
				{
					object nval = remove ? null : m_owner;
					if (m_reverseProperty.GetValue(item, null) != nval)
						m_reverseProperty.SetValue(item, remove ? null : m_owner, null);
				}
				else
				{
					object col = m_reverseProperty.GetValue(item, null);
					if (col == null)
						return;
					else if (col as System.Collections.ICollection == null)
						throw new System.Exception("Reverse property must be of type " + m_owner.GetType().FullName + " or ICollection");

					System.Reflection.MethodInfo mi = col.GetType().GetMethod("Contains");
					if (mi == null)
						throw new System.Exception("Reverse property type " + col.GetType().FullName + " does not contain a method called Contains");
					bool contains = System.Convert.ToBoolean(mi.Invoke(col, new object[] { m_owner }));
					if (!contains)
					{
						mi = col.GetType().GetMethod(remove ? "Remove" : "Add");
						if (mi == null)
							throw new System.Exception("Reverse property type " + col.GetType().FullName + " does not contain a method called " + (remove ? "Remove" : "Add"));
						mi.Invoke(col, new object[] { m_owner });
					}

				}

        }

        protected virtual void HookItem(object item)
        {
            UpdateReverse(item, false);
        }

        protected virtual void UnhookItem(object item)
        {
            UpdateReverse(item, true);
        }


    }
    #endregion

    #region " Attribute classes "
    [Flags]
	public enum MemberModifierEnum : int
	{
        None = 0,
		IgnoreWithInsert,
		IgnoreWithUpdate,
		IgnoreWithSelect,
		IgnoreAll = IgnoreWithInsert | IgnoreWithUpdate | IgnoreWithSelect,
		AutoIncrement = IgnoreWithInsert
	}

	public class MemberModifier
		: Attribute
	{
		private MemberModifierEnum m_m;
		public MemberModifier(MemberModifierEnum m)
		{
			m_m = m;
		}
		public MemberModifierEnum Modifier { get { return m_m; } }

		public static MemberModifierEnum CalculateModifier(MemberInfo mi)
		{
			MemberModifier[] m = (MemberModifier[])mi.GetCustomAttributes(typeof(MemberModifier), false);
			if (m == null || m.Length == 0)
				return MemberModifierEnum.None;

			MemberModifierEnum mf = m[0].Modifier;
			for(int i = 1; i < m.Length; i++)
				mf |= m[i].Modifier;

			return mf;
		}
	}

	public class MemberModifierIgnoreWithInsert
		: MemberModifier
	{
		public MemberModifierIgnoreWithInsert()
			: base(MemberModifierEnum.IgnoreWithInsert)
		{
		}
	}

	public class MemberModifierIgnoreWithUpdate
		: MemberModifier
	{
		public MemberModifierIgnoreWithUpdate()
			: base(MemberModifierEnum.IgnoreWithUpdate)
		{
		}
	}

	public class MemberModifierIgnoreWithSelect
		: MemberModifier
	{
		public MemberModifierIgnoreWithSelect()
			: base(MemberModifierEnum.IgnoreWithSelect)
		{
		}
	}

	public class MemberModifierIgnoreAll
		: MemberModifier
	{
		public MemberModifierIgnoreAll()
			: base(MemberModifierEnum.IgnoreAll)
		{
		}
	}

	public class MemberModifierAutoIncrement
		: MemberModifier
	{
		public MemberModifierAutoIncrement()
			: base(MemberModifierEnum.AutoIncrement)
		{
		}
	}

	#endregion

	/// <summary>
	/// This class is an implementation of a simple evaluator that orders writes,
	/// to ensure that all ID's are present upon commit
	/// </summary>
	public class CommitEvaluator
	{
		public static void CommitAll(ArrayList added, ArrayList deleted, ArrayList modified)
		{
			//Step 1, find types with autoincrement keys
			Hashtable types = new Hashtable();
			Hashtable specialItems = new Hashtable();
			foreach(DataClassBase o in added)
			{
				if (o.IsPrimaryKeyAutogenerated)
					specialItems.Add(o, o);

				o.Commit();
			}

			//Null update any deleted items
			Hashtable removedItems = new Hashtable();
			foreach(object o in deleted)
				specialItems.Add(o, null);

			//Step 2, re-assign to update internal ID's
			Hashtable classProperties = new Hashtable();
			ArrayList totals = new ArrayList();
			totals.AddRange(added);
			totals.AddRange(modified);

            //TODO: Can this be done better, now that the Guid system registers the references?
			foreach(DataClassBase o in totals)
			{
				if (!classProperties.ContainsKey(o.GetType()))
					classProperties.Add(o.GetType(), FindObjProps(o));

				ArrayList piList = (ArrayList)classProperties[o.GetType()];
                foreach (PropertyInfo pi in piList)
                {
                    object ox = pi.GetValue(o, null);
                    if (ox != null && specialItems.ContainsKey(ox))
                    {
                        pi.SetValue(o, specialItems[pi.GetValue(o, null)], null);
                        if (!modified.Contains(o))
                            modified.Add(o);
                    }
                }
			}

			//Step 3, update all items
			foreach(DataClassBase b in modified)
				b.Commit();

			foreach(DataClassBase b in deleted)
				b.Commit();
		}

		private static ArrayList FindObjProps(object o)
		{
			ArrayList res = new ArrayList();
			foreach(PropertyInfo pi in o.GetType().GetProperties())
			{
				if (!pi.CanWrite || !pi.CanRead)
					continue;
				if (pi.PropertyType.IsValueType || pi.PropertyType == typeof(string))
					continue;

				res.Add(pi);
			}

			return res;
		}
	}


	/// <summary>
	/// This class is used to transfer data to and from a configureable data provider
	/// </summary>
	public class ConfigureProperties
	{
		public string Connectionstring;
		public string DestinationDir;
		public string Namespace;
	}

	/// <summary>
	/// If a data provider supports assisted configuration, it must implement this interface.
	/// Must also have a default constructor.
	/// </summary>
	public interface IConfigureAbleDataProvider
	{
		/// <summary>
		/// This method should present a dialog for the user to configure the data provider.
		/// </summary>
		/// <param name="owner">The owner dialog</param>
		/// <param name="previousConnectionString">Any previously configured properties</param>
		/// <returns>The new connection properties, or null if the setup was cancelled</returns>
		ConfigureProperties Configure(System.Windows.Forms.Form owner, ConfigureProperties previousConnectionProperties);

		/// <summary>
		/// Returns a user identifiable name for the provider.
		/// </summary>
		string FriendlyName { get; }

		/// <summary>
		/// This method should return a configuration for the provider, given the commandline arguments, or return null if the commandline was not meaningfull to the provider.
		/// </summary>
		/// <param name="arguments">The commandline arguments</param>
		/// <returns>A configuration for the provider, or null if the arguments where not meaningfull for the provider</returns>
		ConfigureProperties AutoConfigure(string[] arguments);

		/// <summary>
		/// Returns a dataprovider, given the connectionstring
		/// </summary>
		/// <param name="connectionstring"></param>
		/// <returns></returns>
		IDataProvider GetProvider(string connectionstring);
	}

	/// <summary>
	/// All data providers must implement this interface
	/// </summary>
	public interface IDataProvider
	{
		void DeleteRow(string tablename, string primarycolumnname, object primaryvalue);
		Data[] SelectRow(string tablename, string primarycolumnname, object primaryvalue);
		Data[][] SelectRows(string tablename, string filter);
		Data[][] SelectRows(string tablename, string filter, object[] values);
		Data[][] SelectRows(string tablename, QueryModel.Operation operation);
		void UpdateRow(string tablename, string primarycolumnname, object primaryvalue, params Data[] values);
		void InsertRow(string tablename, params Data[] values);
		string GetPrimaryKey(string tablename);
		string[] GetTablenames();
		Data[] GetStructure(string sql);
		Data[] GetTableStructure(string tablename);
		void Close();
		string ConnectionString{get;set;}
		object GetNullValue(Type type);

		void BeginTransaction(Guid id);
		void CommitTransaction(Guid id);
		void RollbackTransaction(Guid id);

        object GetLastAutogeneratedValue(string tablename);
	}

	/// <summary>
	/// This data structure is used to return data from a select performed on the provider into the datafetcher.
	/// </summary>
	public struct Data
	{
		public string Name;
		public object Value;
		public Type Type;
		public Data(string name, object value, Type type)
		{
			Name = name;
			Value = value;
			Type = type;
		}
		public Data(string name, object value)
		{
			Name = name;
			Value = value;
			Type = null;
		}
	}

	/// <summary>
	/// This enum represents the different states an object may have
	/// </summary>
	public enum ObjectStates
	{
		/// <summary>
		/// The object is loaded from the database, and may be modified
		/// </summary>
		Default,

		/// <summary>
		/// The object is not yet created in the database
		/// </summary>
		New,

		/// <summary>
		/// The object has been marked for deletion in the database
		/// </summary>
		Deleted,
	}

	/// <summary>
	/// This enum represents the different command types a provider can perform
	/// </summary>
	public enum DataActions
	{
		Update,
		Insert,
		Delete,
		Fetch,
	}
}