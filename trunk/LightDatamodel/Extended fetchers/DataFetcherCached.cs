#region Disclaimer / License
// Copyright (C) 2008, Kenneth Skovhede
// http://www.hexad.dk, opensource@hexad.dk
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
// 
#endregion
using System;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;

namespace System.Data.LightDatamodel
{
	/// <summary>
	/// Will fetch and commit objects directly to source
	/// </summary>
	public class DataFetcherCached : DataFetcher, IDataFetcherCached
	{
		protected SortedList<Guid, IDataClass> m_guidCache = new SortedList<Guid, IDataClass>();
		protected SortedList<string, SortedList<object, IDataClass>> m_cache = new SortedList<string, SortedList<object, IDataClass>>();
		protected ArrayList m_newobjects = new ArrayList();
		protected ArrayList m_deletedobjects = new ArrayList();
		protected SortedList<string, Type> m_knownTypes = new SortedList<string, Type>();

		public SortedList<string, Type> KnownTypes { get { return m_knownTypes; } }

		public bool IsDirty
		{
			get
			{
				if ((m_newobjects.Count > 0) || (m_deletedobjects.Count > 0))
					return true;

				foreach (SortedList<object, IDataClass> table in m_cache.Values)
					foreach (IDataClass obj in table.Values)
						if (obj.IsDirty)
							return true;

				return false;
			}
		}

		public DataFetcherCached(IDataProvider provider) : base(provider)
		{
		}

		/*
        
		protected class ReferenceLink
		{
			public DataClassBase CurrentObject;
			public DataClassBase LinkOwner;
			public FieldInfo IDField;
		}
         
		protected Hashtable m_references = new Hashtable();
        
		public void SetCurrentObject(DataClassBase owner, string propertyname, object value)
		{
			if (!m_references.ContainsKey(owner))
				m_references.Add(owner, new Hashtable());
			((Hashtable)m_references[owner])[propertyname] = value;
		}

		public DataClassBase GetCurrentObject(DataClassBase owner, string propertyname)
		{
			if (!m_references.ContainsKey(owner))
				m_references.Add(owner, new Hashtable());
			Hashtable ht = (Hashtable)m_references[owner];
			if (!ht.ContainsKey(propertyname))
				return null;
			else
				return ht[propertyname];
		}
        
		*/

		public virtual void CommitAll()
		{
			Guid transactionID = Guid.NewGuid();
			bool inTransaction = false;

			m_provider.BeginTransaction(transactionID);
			inTransaction = true;

			try
			{
				ArrayList updated = new ArrayList();
				foreach (SortedList<object, IDataClass> table in m_cache.Values)
					foreach(IDataClass obj in table.Values)
						if(obj.IsDirty)
							updated.Add(obj);

				ArrayList added = new ArrayList(m_newobjects);
				ArrayList removed = new ArrayList(m_deletedobjects);

				CommitEvaluator.CommitAll(added, removed, updated);

				m_provider.CommitTransaction(transactionID);
				m_newobjects = new ArrayList();
				m_deletedobjects = new ArrayList();
				inTransaction = false;
			}
			finally
			{
				if (inTransaction)
					m_provider.RollbackTransaction(transactionID);
			}
		}

		protected override void HookObject(IDataClass obj)
		{
			base.HookObject(obj);
			string tablename = obj.GetType().Name;
			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
			if (!(obj as DataClassExtended).IsPrimaryKeyAutogenerated || (obj as DataClassExtended).ExistsInDB)
			{
				if (m_cache[tablename].ContainsKey(obj.UniqueValue)) m_cache[tablename].Remove(obj.UniqueValue);
				m_cache[tablename].Add(obj.UniqueValue, obj);
			}
			m_guidCache[(obj as DataClassExtended).m_guid] = obj;
		}

		/// <summary>
		/// This will load a list of arbitary objects
		/// If the given object is a DataClassBase it will be hooked into the DataFetcher
		/// DataCustomClassBase will also have it's values filled
		/// All others will just be filled with the data
		/// </summary>
		/// <param name="type">The type of objects to load</param>
		/// <param name="filter">The filter used to select objects</param>
		/// <returns>All matching objects</returns>
		public override DATACLASS[] GetObjects<DATACLASS>(string filter, params object[] parameters)
		{
			Type type = typeof(DATACLASS);
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);
			
			//This ensures that we always query the memory
			return GetObjects<DATACLASS>(QueryModel.Parser.ParseQuery(filter, parameters));

			/*Data[][] data = m_provider.SelectRows(tablename, filter);
			return InsertObjectsInCache(type, data);*/
		}

		/// <summary>
		/// Will return all objects where the IdProperty is set to the referenceObject
		/// </summary>
		/// <param name="type">The type of the objects to load</param>
		/// <param name="properyName">The name of the reference property</param>
		/// <param name="idProperty">The name of the IdProperty on the type</param>
		/// <param name="refObj">The reference object to match</param>
		/// <returns></returns>
		public virtual DATACLASS[] GetReferenceObjects<DATACLASS>(string properyName, string idProperty, IDataClass refObj) where DATACLASS : IDataClass
		{
			Type type = typeof(DATACLASS);
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);

			if ((refObj as DataClassExtended).ExistsInDB)
			{
				OnBeforeDataConnection(refObj, DataActions.Fetch);
				Data[][] data = m_provider.SelectRows(tablename, idProperty + "=?", new object[] { refObj.UniqueValue });
				if (!refObj.IsDirty)
					return InsertObjectsInCache < DATACLASS>(data);

				InsertObjectsInCache < DATACLASS>(data);
			}

			return GetObjectsFromCache<DATACLASS>(properyName + ".Guid=?" + (refObj as DataClassExtended).Guid);
		}

        public override DATACLASS[] GetObjects<DATACLASS>()
        {
            return GetObjects<DATACLASS>("");
        }

        public virtual DATACLASS[] GetObjects<DATACLASS>(string query) where DATACLASS : IDataClass
        {
            return GetObjects<DATACLASS>(QueryModel.Parser.ParseQuery(query));
        }

		/// <summary>
		/// This will load a list of arbitary objects
		/// If the given object is a DataClassBase it will be hook into the DataFetcher
		/// DataCustomClassBase will also have it's values filled
		/// All others will just be filled with the data
		/// </summary>
		/// <param name="type">The type of objects to load</param>
		/// <param name="operation">The filter used to select objects</param>
		/// <returns>All matching objects</returns>
		public virtual DATACLASS[] GetObjects<DATACLASS>(QueryModel.Operation operation) where DATACLASS : IDataClass
		{
			Type type = typeof(DATACLASS);
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);
            if (!m_cache.ContainsKey(tablename))
                m_cache[tablename] = new SortedList<object, IDataClass>();

            QueryModel.Operation filter = QueryModel.Parser.ParseQuery("Not (" + ((DataClassBase)Activator.CreateInstance(type)).UniqueColumn + " IN ?)", m_cache[tablename].Keys);

			QueryModel.Operation op = new QueryModel.Operation(QueryModel.Operators.And, new QueryModel.OperationOrParameter[] {filter, operation});

			Data[][] data = m_provider.SelectRows(tablename, op);
			InsertObjectsInCache<DATACLASS>(data);
			return operation.EvaluateList<DATACLASS>(m_cache[tablename].Values);
		}

        public virtual object[] GetObjects(Type type)
        {
            return GetObjects(type, "");
        }

        public virtual object[] GetObjects(Type type, string query)
        {
            return GetObjects(type, QueryModel.Parser.ParseQuery(query));
        }

		public virtual object[] GetObjects(Type type, QueryModel.Operation operation)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);
            if (!m_cache.ContainsKey(tablename))
                m_cache[tablename] = new SortedList<object, IDataClass>();

            QueryModel.Operation filter = QueryModel.Parser.ParseQuery("Not (" + ((DataClassBase)Activator.CreateInstance(type)).UniqueColumn + " IN ?)", m_cache[tablename].Keys);

            QueryModel.Operation op = new QueryModel.Operation(QueryModel.Operators.And, new QueryModel.OperationOrParameter[] { filter, operation });

			Data[][] data = m_provider.SelectRows(tablename, op);
			InsertObjectsInCache(type, data);
			return operation.EvaluateList(m_cache[tablename].Values);
		}

		/// <summary>
		/// Discards all changes from the object, and removes it from the internal cache
		/// </summary>
		/// <param name="obj">The object to discard</param>
		public void DiscardObject(DataClassExtended obj)
		{
			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());

			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());

			if (m_guidCache.ContainsKey(obj.Guid))
				m_guidCache.Remove(obj.Guid);
            
			if (obj.ExistsInDB)
				if (m_cache[tablename].ContainsKey(obj.UniqueValue))
					m_cache[tablename].Remove(obj.UniqueValue);
		}

		/// <summary>
		/// Reads objects from the cache, will not communicate with the database
		/// </summary>
		/// <param name="type"></param>
		/// <param name="filter"></param>
		/// <param name="parameters"></param>
		/// <returns></returns>
		public DATACLASS[] GetObjectsFromCache<DATACLASS>(string filter, params object[] parameters) where DATACLASS : IDataClass
		{
			return GetObjectsFromCache <DATACLASS>(QueryModel.Parser.ParseQuery(filter, parameters));
		}

		/// <summary>
		/// Reads objects from the cache, will not communicate with the database
		/// </summary>
		/// <param name="type"></param>
		/// <param name="query"></param>
		/// <returns></returns>
		public DATACLASS[] GetObjectsFromCache<DATACLASS>(QueryModel.Operation query) where DATACLASS : IDataClass
		{
			Type type = typeof(DATACLASS);
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);

			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());

			List<IDataClass> allItems = new List<IDataClass>();
			if (m_provider as DataProviderNested != null)
			{
				Data[][] d = ((DataProviderNested)m_provider).SelectRowsFromCache(tablename, query);
				if (d != null)
					InsertObjectsInCache<DATACLASS>(d);
			}
			allItems.AddRange(m_cache[tablename].Values);
			foreach (DataClassBase o in m_newobjects)
				if (o.GetType().IsAssignableFrom(type))
					allItems.Add(o);

			return query.EvaluateList<DATACLASS>(allItems);
		}

		public object[] GetObjectsFromCache(Type type, QueryModel.Operation query)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, type);

			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());

			List<IDataClass> allItems = new List<IDataClass>();
			if (m_provider as DataProviderNested != null)
			{
				Data[][] d = ((DataProviderNested)m_provider).SelectRowsFromCache(tablename, query);
				if (d != null)
					InsertObjectsInCache(type, d);
			}
			allItems.AddRange(m_cache[tablename].Values);
			foreach (DataClassBase o in m_newobjects)
				if (o.GetType().IsAssignableFrom(type))
					allItems.Add(o);

			return query.EvaluateList(allItems);
		}


		private DATACLASS[] InsertObjectsInCache<DATACLASS>(Data[][] data) where DATACLASS : IDataClass
		{
			Type type = typeof(DATACLASS);
			DATACLASS[] ret = new DATACLASS[data.Length];
			DataClassLevels level = GetDataClassLevel(type);

			if (level >= DataClassLevels.Base)
			{
				string tablename = type.Name;
				if (!m_knownTypes.ContainsKey(tablename)) m_knownTypes.Add(tablename, type);
				if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());

				QueryModel.Operation opdeleted = QueryModel.Parser.ParseQuery("GetType.FullName = ? AND UniqueValue = ?", type.FullName);

				System.Collections.Generic.List<DATACLASS> res = new System.Collections.Generic.List<DATACLASS>();

				for(int i = 0; i < ret.Length; i++)
				{
					DATACLASS newobj = Activator.CreateInstance < DATACLASS>();
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					if (!m_cache[tablename].ContainsKey(newobj.UniqueValue))
					{
						if (opdeleted.EvaluateList(m_deletedobjects, newobj.UniqueValue).Length > 0)
							continue;

						(newobj as DataClassBase).m_dataparent = this;
						(newobj as DataClassBase).m_state = ObjectStates.Default;
						(newobj as DataClassBase).m_isdirty = false;
						if (m_provider as DataProviderNested == null) (newobj as DataClassExtended).m_existsInDB = true;
						res.Add(newobj);

						//add to cache
						HookObject(newobj);
						OnAfterDataConnection(newobj, DataActions.Fetch);
					}
					else
					{
						res.Add((DATACLASS)m_cache[tablename][newobj.UniqueValue]);
						OnAfterDataConnection(newobj, DataActions.Fetch);
					}
				}
				ret = res.ToArray();
			}
			else if(level == DataClassLevels.View)
			{
				for(int i = 0; i < ret.Length; i++)
				{
					DATACLASS newobj = Activator.CreateInstance < DATACLASS>();
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					(newobj as DataClassBase).m_dataparent = this;
					ret[i] = newobj;
					OnAfterDataConnection(newobj, DataActions.Fetch);
				}
			}
			else
			{
				for(int i = 0; i < ret.Length; i++)
				{
					DATACLASS newobj = Activator.CreateInstance < DATACLASS>();
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					ret[i] = newobj;
					OnAfterDataConnection(newobj, DataActions.Fetch);
				}
			}

			return ret;
		}

		private object[] InsertObjectsInCache(Type type, Data[][] data)
		{
			object[] ret = new object[data.Length];
			DataClassLevels level = GetDataClassLevel(type);

			if (level >= DataClassLevels.Base)
			{
				string tablename = type.Name;
				if (!m_knownTypes.ContainsKey(tablename)) m_knownTypes.Add(tablename, type);
				if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());

				QueryModel.Operation opdeleted = QueryModel.Parser.ParseQuery("GetType.FullName = ? AND UniqueValue = ?", type.FullName);

				ArrayList res = new ArrayList();

				for (int i = 0; i < ret.Length; i++)
				{
					object newobj = Activator.CreateInstance(type);
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					if (!m_cache[tablename].ContainsKey((newobj as DataClassBase).UniqueValue))
					{
						if (opdeleted.EvaluateList(m_deletedobjects, (newobj as DataClassBase).UniqueValue).Length > 0)
							continue;

						(newobj as DataClassBase).m_dataparent = this;
						(newobj as DataClassBase).m_state = ObjectStates.Default;
						(newobj as DataClassBase).m_isdirty = false;
						if (m_provider as DataProviderNested == null) (newobj as DataClassExtended).m_existsInDB = true;
						res.Add(newobj);

						//add to cache
						HookObject(newobj as DataClassBase);
						OnAfterDataConnection(newobj, DataActions.Fetch);
					}
					else
					{
						res.Add(m_cache[tablename][(newobj as DataClassBase).UniqueValue]);
						OnAfterDataConnection(newobj, DataActions.Fetch);
					}
				}
				ret = res.ToArray();
			}
			else if (level == DataClassLevels.View)
			{
				for (int i = 0; i < ret.Length; i++)
				{
					object newobj = Activator.CreateInstance(type);
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					(newobj as DataClassBase).m_dataparent = this;
					ret[i] = newobj;
					OnAfterDataConnection(newobj, DataActions.Fetch);
				}
			}
			else
			{
				for (int i = 0; i < ret.Length; i++)
				{
					object newobj = Activator.CreateInstance(type);
					ObjectTransformer.PopulateDataClass(newobj, data[i], m_provider);
					ret[i] = newobj;
					OnAfterDataConnection(newobj, DataActions.Fetch);
				}
			}

			return ret;
		}

		/// <summary>
		/// Marks an object for deletion
		/// </summary>
		/// <param name="id">ID of the item</param>
		/// <param name="type">Type of the item to delete</param>
		public override void DeleteObject<DATACLASS>(object id)
		{
			DATACLASS tobedeleted = GetObjectById<DATACLASS>(id);
			if(tobedeleted != null) Remove((IDataClass)tobedeleted);
		}

		/// <summary>
		/// Gets an object by its Guid
		/// </summary>
		/// <param name="key">The key to look for, must be of type Guid</param>
		/// <returns>The item matching the Guid, or null</returns>
		public virtual DATACLASS GetObjectByGuid<DATACLASS>(Guid key) where DATACLASS : IDataClass
		{
			if (key == Guid.Empty) return default(DATACLASS);

			if (m_guidCache.ContainsKey((Guid)key))
				return (DATACLASS)m_guidCache[(Guid)key];
			else if (m_provider as DataProviderNested != null)
			{
				DATACLASS o = ((DataProviderNested)m_provider).BaseFetcher.GetObjectByGuid<DATACLASS>(key);
				if (o == null)
					return default(DATACLASS);
				Data[] data = (m_provider as DataProviderNested).FromObjectToData(o);
				return InsertObjectsInCache<DATACLASS>(new Data[][] { data })[0];
			}
			else
				return default(DATACLASS);
		}

		public virtual object GetObjectByGuid(Guid key)
		{
			if (key == Guid.Empty) return null;

			if (m_guidCache.ContainsKey(key))
				return m_guidCache[key];
			else if (m_provider as DataProviderNested != null)
			{
				object o = ((DataProviderNested)m_provider).BaseFetcher.GetObjectByGuid(key);
				if (o == null) return null;
				Data[] data = (m_provider as DataProviderNested).FromObjectToData(o);
				Type type = o.GetType();
				return InsertObjectsInCache(type, new Data[][] { data })[0];
			}
			else
				return null;
		}

		/// <summary>
		/// This will load the given DataClassBase object
		/// </summary>
		/// <param name="id"></param>
		/// <returns></returns>
		public override DATACLASS GetObjectById<DATACLASS>(object id)
		{
			Type type = typeof(DATACLASS);
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename)) m_knownTypes.Add(tablename, type);

			if(GetDataClassLevel(type) < DataClassLevels.Base) throw new Exception("This object cannot be fetched by primary key. Use GetObjects instead");

			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
			if(!m_cache[tablename].ContainsKey(id))
			{
				//Fetch From Data source
				DataClassExtended newobj = (DataClassExtended)Activator.CreateInstance(type);
				Data[] data = m_provider.SelectRow(tablename, newobj.UniqueColumn, id);
				if (data == null) return default(DATACLASS);
				InsertObjectsInCache<DATACLASS>(new Data[][] { data });
			}

			return (DATACLASS)m_cache[tablename][id];
		}

		public override object GetObjectById(Type type, object id)
		{
			string tablename = type.Name;
			if (!m_knownTypes.ContainsKey(tablename)) m_knownTypes.Add(tablename, type);

			if (GetDataClassLevel(type) < DataClassLevels.Base) throw new Exception("This object cannot be fetched by primary key. Use GetObjects instead");

			if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
			if (!m_cache[tablename].ContainsKey(id))
			{
				//Fetch From Data source
				DataClassExtended newobj = (DataClassExtended)Activator.CreateInstance(type);
				Data[] data = m_provider.SelectRow(tablename, newobj.UniqueColumn, id);
				if (data == null) return null;
				InsertObjectsInCache(type, new Data[][] { data });
                if (!m_cache[tablename].ContainsKey(id))
                    return null;
			}

			return m_cache[tablename][id];
		}

		public virtual void Remove(IDataClass obj)
		{
			string tablename = obj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, obj.GetType());

			if(obj.ObjectState == ObjectStates.New)
			{
				m_newobjects.Remove(obj);
				m_guidCache.Remove((obj as DataClassExtended).m_guid);
			}
			else
			{
				if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
				m_cache[tablename].Remove(obj.UniqueValue);
				m_deletedobjects.Add(obj);
				(obj as DataClassExtended).m_state = ObjectStates.Deleted;
			}
		}

		public virtual void Add(IDataClass newobj)
		{
			(newobj as DataClassExtended).m_dataparent = this;
			(newobj as DataClassExtended).m_state = ObjectStates.New;
			m_newobjects.Add(newobj);
			(newobj as DataClassExtended).SetExistsInDB(false);

			string tablename = newobj.GetType().Name;
			if (!m_knownTypes.ContainsKey(tablename))
				m_knownTypes.Add(tablename, newobj.GetType());
			m_guidCache.Add((newobj as DataClassExtended).m_guid, newobj);
		}

		internal void ReRegisterObjectGuid(Guid oldkey, IDataClass obj)
		{
			m_guidCache.Remove(oldkey);
			m_guidCache[(obj as DataClassExtended).m_guid] = obj;
		}

		public override DATACLASS CreateObject<DATACLASS>()
		{
			DATACLASS newobj = Activator.CreateInstance<DATACLASS>();
			Add((IDataClass)newobj);
			return newobj;
		}

		public override object CreateObject(Type dataclass)
		{
			object newobj = Activator.CreateInstance(dataclass);
			Add((IDataClass)newobj);
			return newobj;
		}

		protected internal override void RefreshObject(IDataClass obj)
		{
			if(obj.ObjectState == ObjectStates.Deleted) return;
			if ((obj as DataClassExtended).IsPrimaryKeyAutogenerated && !(obj as DataClassExtended).ExistsInDB)
			{
				(obj as DataClassExtended).m_dataparent = this;
				(obj as DataClassExtended).m_state = ObjectStates.Default;
				(obj as DataClassExtended).m_isdirty = false;
				return;
			}

			base.RefreshObject(obj);
		}

		public override void Commit(IDataClass obj)
		{
			string tablename = obj.GetType().Name;

			//sql
			if (obj.ObjectState == ObjectStates.Default)
			{
				if ((obj as DataClassExtended).ExistsInDB || !(obj as DataClassExtended).IsPrimaryKeyAutogenerated)
					base.Commit(obj);
			}
			else if (obj.ObjectState == ObjectStates.New)
			{
				base.Commit(obj);		//TODO: Beware of the events

				if (m_provider as DataProviderNested == null)
				{
					(obj as DataClassExtended).SetExistsInDB(true);
					if ((obj as DataClassExtended).IsPrimaryKeyAutogenerated) (obj as DataClassExtended).SetPrimaryKey(m_provider.GetLastAutogeneratedValue(tablename));
				}
				if ((obj as DataClassExtended).ExistsInDB || !(obj as DataClassExtended).IsPrimaryKeyAutogenerated)
				{
					if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
					m_cache[tablename].Add(obj.UniqueValue, obj);
				}
			}
			else if (obj.ObjectState == ObjectStates.Deleted)
			{
				base.Commit(obj);		//TODO: Beware of the events
				m_deletedobjects.Remove(obj);
				m_guidCache.Remove((obj as DataClassExtended).m_guid);
				if (!m_cache.ContainsKey(tablename)) m_cache.Add(tablename, new SortedList<object, IDataClass>());
				m_cache[tablename].Remove(obj.UniqueValue);
			}
		}
	}

	/// <summary>
	/// This class is an implementation of a simple evaluator that orders writes,
	/// to ensure that all ID's are present upon commit
	/// </summary>
	public class CommitEvaluator
	{
		public static void CommitAll(ArrayList added, ArrayList deleted, ArrayList modified)
		{
			//Step 1, find types with autoincrement keys
			Hashtable types = new Hashtable();
			Hashtable specialItems = new Hashtable();
			foreach(DataClassExtended o in added)
			{
				if (o.IsPrimaryKeyAutogenerated)
					specialItems.Add(o, o);

				o.DataParent.Commit(o);
			}

			//Null update any deleted items
			Hashtable removedItems = new Hashtable();
			foreach(object o in deleted)
				specialItems.Add(o, null);

			//Step 2, re-assign to update internal ID's
            Dictionary<Type, List<PropertyInfo>> classProperties = new Dictionary<Type, List<PropertyInfo>>();
			ArrayList totals = new ArrayList();
			totals.AddRange(added);
			totals.AddRange(modified);

			//TODO: Can this be done better, now that the Guid system registers the references?
			foreach(DataClassBase o in totals)
			{
				if (!classProperties.ContainsKey(o.GetType()))
					classProperties.Add(o.GetType(), FindObjProps(o));

                foreach (PropertyInfo pi in classProperties[o.GetType()])
				{
					object ox = pi.GetValue(o, null);
					if (ox != null && specialItems.ContainsKey(ox))
					{
						pi.SetValue(o, specialItems[pi.GetValue(o, null)], null);
						if (!modified.Contains(o))
							modified.Add(o);
					}
				}
			}

			//Step 3, update all items
			foreach (IDataClass b in modified)
				b.DataParent.Commit(b);

			foreach(IDataClass b in deleted)
				b.DataParent.Commit(b);
		}

		private static List<PropertyInfo> FindObjProps(object o)
		{
            List<PropertyInfo> res = new List<PropertyInfo>();
			foreach(PropertyInfo pi in o.GetType().GetProperties())
			{
				if (!pi.CanWrite || !pi.CanRead)
					continue;
				if (pi.PropertyType.IsValueType || pi.PropertyType == typeof(string))
					continue;

				res.Add(pi);
			}

			return res;
		}
	}

}
