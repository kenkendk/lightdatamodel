using System;
using System.Collections.Generic;
using System.Text;

namespace System.Data.LightDatamodel
{
    public class RelationManager : IRelationManager
    {
        private RelationManagerConfig m_config;

        /// <summary>
        /// This table contains all references for a given propertykey and object
        /// </summary>
        private Dictionary<string, Dictionary<Guid, List<Guid>>> m_references;
        /// <summary>
        /// This contains all known objects
        /// </summary>
        private Dictionary<Guid, IDataClass> m_hookedObjects;
        /// <summary>
        /// This contains all known objects
        /// </summary>
        private Dictionary<IDataClass, Guid> m_revHookedObjects;

        /// <summary>
        /// The owner, used to fetch items initially
        /// </summary>
        private IDataFetcherCached m_owner;

        /// <summary>
        /// This contains the objects existence state
        /// </summary>
        private Dictionary<Guid, bool> m_existsInDb;


        public RelationManager(IDataFetcherCached owner)
        {
            m_config = owner.ObjectTransformer.TypeConfiguration.RelationConfig;
            m_references = new Dictionary<string, Dictionary<Guid, List<Guid>>>();
            m_hookedObjects = new Dictionary<Guid, IDataClass>();
            m_revHookedObjects = new Dictionary<IDataClass, Guid>();
            m_existsInDb = new Dictionary<Guid, bool>();
            m_owner = owner;

            m_owner.AfterDataChange += new DataChangeEventHandler(UpdateIDValue);
            m_owner.AfterDataConnection += new DataConnectionEventHandler(owner_AfterDataConnection);

            /*foreach (TypeConfiguration.MappedClass mc in owner.ObjectTransformer.TypeConfiguration.MappedClasses)
                foreach (TypeConfiguration.ReferenceField rf in mc.ReferenceColumns.Values)
                    this.AddRelation(rf.PropertyName, rf.LocalField, rf.ReverseField);*/
        }

        void owner_AfterDataConnection(object sender, DataActions action)
        {
            if (action == DataActions.Insert && sender as IDataClass != null && m_revHookedObjects.ContainsKey(sender as IDataClass))
            {
                TypeConfiguration.MappedClass mc = m_config.TypeConfiguration.GetTypeInfo(sender);
                if (mc.PrimaryKey.IsAutoGenerated && ExistsInDb(sender as IDataClass))
                    UpdateIDValueInternal(mc.PrimaryKey.PropertyName, GetGuidForObject(sender as IDataClass), sender.GetType(), mc.PrimaryKey.Field.GetValue(sender), false);

            }
        }

        public bool ExistsInDb(IDataClass item)
        {
            return m_existsInDb[GetGuidForObject(item)];
        }

        public void SetExistsInDb(IDataClass item, bool state)
        {
            m_existsInDb[GetGuidForObject(item)] = state;
       }

        public bool IsRegistered(IDataClass item)
        {
            return m_revHookedObjects.ContainsKey(item);
        }

        public IDataClass GetObjectByGuid(Guid g)
        {
            return m_hookedObjects[g];
        }

        public Guid GetGuidForObject(IDataClass item)
        {
            if (item == null)
                return Guid.Empty;
            else if (m_revHookedObjects.ContainsKey(item))
                return m_revHookedObjects[item];
            else throw new Exception("The given object is not registered in the current context. Please add it or load it through the correct datafetcher");
        }

        public Guid RegisterObject(IDataClass item)
        {
            return RegisterObject(Guid.NewGuid(), item);
        }

        public Guid RegisterObject(Guid guid, IDataClass item)
        {
            m_hookedObjects.Add(guid, item);

            m_revHookedObjects.Add(item, guid);
            if (!m_existsInDb.ContainsKey(guid))
                m_existsInDb[guid] = false;
            return guid;
        }

        public bool HasGuid(Guid g)
        {
            return m_hookedObjects.ContainsKey(g);
        }


        public void ReassignGuid(Guid o, Guid n)
        {
            IDataClass item = m_hookedObjects[o];
            m_hookedObjects.Remove(o);
            m_revHookedObjects.Remove(item);
            RegisterObject(n, item);
        }

        public void DeleteObject(IDataClass itm)
        {
            if (itm == null || !m_revHookedObjects.ContainsKey(itm))
                return;

            Guid g = GetGuidForObject(itm);
            UnregisterObject(itm);
            foreach (Dictionary<Guid, List<Guid>> ix in m_references.Values)
            {
                if (ix.ContainsKey(g))
                    ix.Remove(g);

                foreach (List<Guid> ixm in ix.Values)
                    if (ixm.Contains(g))
                        ixm.Remove(g);
            }
        }

        private void UpdateIDValueInternal(string propertyname, Guid owner, Type ownerType, object newvalue, bool usePropertyAccess)
        {
            string[] propkeys = m_config.GetPropKeysByID(ownerType);

            foreach (string propkey in propkeys)
            {
                if (!m_references.ContainsKey(propkey))
                    m_references.Add(propkey, new Dictionary<Guid, List<Guid>>());

                KeyValuePair<TypeConfiguration.MappedField, TypeConfiguration.MappedField> mapping = m_config.GetMapping(propkey);
                if (mapping.Value.Field.DeclaringType == ownerType)
                {
                    if (m_config.TypeConfiguration.GetTypeInfo(ownerType).PrimaryKey.PropertyName == propertyname)
                        SetIdValue(m_config.GetRelationKey(ownerType, propkey), ownerType, owner, newvalue, usePropertyAccess);
                }
                else
                {
                    if (mapping.Key.PropertyName == propertyname)
                        SetReferenceObject(m_config.GetRelationKey(ownerType, propkey), GetObjectByGuid(owner) , m_owner.GetObjectById(mapping.Value.Field.DeclaringType, newvalue) as IDataClass);
                }
            }
        }

        public void UpdateIDValue(object sender, string propertyname, object oldvalue, object newvalue)
        {
            if (sender as IDataClass == null || !m_revHookedObjects.ContainsKey(sender as IDataClass))
                return;

            UpdateIDValueInternal(propertyname, GetGuidForObject(sender as IDataClass), sender.GetType(), newvalue, true);
        }

        public void UnregisterObject(Guid g)
        {
            IDataClass item = m_hookedObjects[g];
            m_revHookedObjects.Remove(item);
            m_hookedObjects.Remove(g);

            foreach (Dictionary<Guid, List<Guid>> ix in m_references.Values)
                if (ix.ContainsKey(g))
                    ix.Remove(g);
       }

        public void UnregisterObject(IDataClass item)
        {
            UnregisterObject(GetGuidForObject(item));

        }

        private Dictionary<Guid, List<Guid>> GetRelDict(string propertyname, Type type)
        {
            string propkey = m_config.GetPropKey(type, propertyname);
            if (propkey == null)
                throw new Exception(string.Format("Key {0} was not registered for relations on type {1}", propertyname, type.FullName));
            if (!m_references.ContainsKey(propkey))
                m_references.Add(propkey, new Dictionary<Guid, List<Guid>>());
            return m_references[propkey];
        }

        private Type GetReverseType(string relationKey, Type type)
        {
            string propKey = m_config.GetPropKey(type, relationKey);
            if (m_config.GetMapping(propKey).Key.Field.DeclaringType == type)
                return m_config.GetMapping(propKey).Value.Field.DeclaringType;
            else
                return m_config.GetMapping(propKey).Key.Field.DeclaringType;
        }

        private Dictionary<Guid, List<Guid>> GetRelDict(string propertyname, IDataClass owner)
        {
            return GetRelDict(propertyname, owner.GetType());
        }

        private void SetIdValue(string relationKey, Type ownerType, Guid owner, object newval, bool usePropertyAccess)
        {
            string propkey = m_config.GetPropKey(ownerType, relationKey);
            KeyValuePair<TypeConfiguration.MappedField, TypeConfiguration.MappedField> mapping = m_config.GetMapping(propkey);
            if (mapping.Value.Field.DeclaringType == ownerType)
            {
                Dictionary<Guid, List<Guid>> dict = m_references[propkey];
                if (dict.ContainsKey(owner))
                    foreach (Guid o in new List<Guid>(dict[owner]))
                    {
                        if (!HasGuid(o))
                            m_owner.GetObjectByGuid(o);

                        if (mapping.Key.Property != null && usePropertyAccess)
                        {
                            if (newval == null)
                                newval = mapping.Value.GetDefaultValue(m_owner.Provider);
                            object prevval = mapping.Key.Property.GetValue(GetObjectByGuid(o), null);
                            if (newval != prevval || (newval != null && !newval.Equals(prevval)))
                                mapping.Key.Property.SetValue(GetObjectByGuid(o), newval, null);
                        }
                        else
                        {
                            if (newval == null)
                                newval = mapping.Value.GetDefaultValue(m_owner.Provider);

                            object prevval = mapping.Key.Field.GetValue(GetObjectByGuid(o));
                            if (newval != prevval || (newval != null && !newval.Equals(prevval)))
                            {
                                mapping.Key.Field.SetValue(GetObjectByGuid(o), newval);
                                ((DataClassBase)GetObjectByGuid(o)).m_isdirty = true;// .SetDirty();
                            }
                        }
                    }
            }

        }

        public void RemoveReferenceObjectInternal(string relationKey, Type ownerType, Guid owner, Guid obj, bool updateId)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, ownerType);
            if (!rels.ContainsKey(owner))
                rels.Add(owner, new List<Guid>());

            if (obj == Guid.Empty)
                return;

            if (rels[owner].Contains(obj))
            {
                if (updateId && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
                    SetIdValue(relationKey, ownerType, owner, null, true);
                
                rels[owner].Remove(obj);
                Type objType = GetReverseType(relationKey, ownerType);

                if (m_config.IsCollection(objType, relationKey))
                    RemoveReferenceObjectInternal(relationKey, objType, obj, owner, updateId);
                else
                    SetReferenceObjectInternal(relationKey, objType, obj, Guid.Empty, updateId);
            }
        }

        public void RemoveReferenceObject(string relationKey, IDataClass owner, IDataClass obj)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, owner.GetType());
            if (!rels.ContainsKey(GetGuidForObject(owner)))
                GetReferenceCollection(relationKey, owner.GetType(), GetGuidForObject(owner));
            RemoveReferenceObjectInternal(relationKey, owner.GetType(), GetGuidForObject(owner), GetGuidForObject(obj), true);
        }

        public void AddReferenceObjectInternal(string relationKey, Type ownerType, Guid owner, Guid obj, bool updateId)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, ownerType);
            if (!rels.ContainsKey(owner))
                rels.Add(owner, new List<Guid>());

            if (obj == Guid.Empty)
                return;

            if (!rels[owner].Contains(obj))
            {
                rels[owner].Add(obj);

                Type objType = GetReverseType(relationKey, ownerType);
                if (updateId && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
                    SetIdValue(relationKey, ownerType, owner, m_config.TypeConfiguration.GetTypeInfo(ownerType).UniqueValue(GetObjectByGuid(owner)), true); 

                if (m_config.IsCollection(objType, relationKey))
                    AddReferenceObjectInternal(relationKey, objType, obj, owner, updateId);
                else
                    SetReferenceObjectInternal(relationKey, objType, obj, owner, updateId);
            }
        }

        public void AddReferenceObject(string relationKey, IDataClass owner, IDataClass obj)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, owner.GetType());
            if (!rels.ContainsKey(GetGuidForObject(owner)))
                GetReferenceCollection(relationKey, owner.GetType(), GetGuidForObject(owner));
            AddReferenceObjectInternal(relationKey, owner.GetType(), GetGuidForObject(owner), GetGuidForObject(obj), true);
        }

        public void SetReferenceObject<T>(string propertyname, IDataClass owner, T value) where T : IDataClass
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(propertyname, owner.GetType());
            if (!rels.ContainsKey(GetGuidForObject(owner)))
                GetReferenceObject(propertyname, owner);
            
            SetReferenceObjectInternal(propertyname, owner.GetType(), GetGuidForObject(owner), GetGuidForObject(value), true);
        }

        public void SetReferenceObject(string relationKey, IDataClass owner, IDataClass obj)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, owner.GetType());
            if (!rels.ContainsKey(GetGuidForObject(owner)))
                GetReferenceObject(relationKey, owner);

            SetReferenceObjectInternal(relationKey, owner.GetType(), GetGuidForObject(owner), GetGuidForObject(obj), true);
        }

        private void SetReferenceObjectInternal(string relationKey, Type ownerType, Guid owner, Guid obj, bool updateId)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, ownerType);
            if (!rels.ContainsKey(owner))
                rels.Add(owner, new List<Guid>());
            Type objType = GetReverseType(relationKey, ownerType);
            if (obj == Guid.Empty)
            {
                while (rels[owner].Count > 0)
                {
                    Guid p = rels[owner][0];

                    if (updateId && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
                        SetIdValue(relationKey, ownerType, owner, null, true);

                    rels[owner].RemoveAt(0);
                    if (m_config.IsCollection(objType, relationKey))
                        RemoveReferenceObjectInternal(relationKey, objType, p, owner, updateId);
                    else
                        SetReferenceObjectInternal(relationKey, objType, p, Guid.Empty, updateId);
                }
            }
            else
            {
                if (!rels[owner].Contains(obj))
                {
                    rels[owner].Add(obj);
                    if (updateId && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
                        SetIdValue(relationKey, ownerType, owner, m_config.TypeConfiguration.GetTypeInfo(ownerType).UniqueValue(GetObjectByGuid(owner)), true);
                    if (m_config.IsCollection(objType, relationKey))
                        AddReferenceObjectInternal(relationKey, objType, obj, owner, updateId);
                    else
                        SetReferenceObjectInternal(relationKey, objType, obj, owner, updateId);
                }
            }
        }

        public T GetReferenceObject<T>(string propertyname, IDataClass owner)
        {
            return (T)GetReferenceObject(propertyname, owner);
        }

        public IDataClass GetReferenceObject(string relationKey, Type ownerType, Guid owner)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, ownerType);
            if (!rels.ContainsKey(owner) && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
            {
                //Load items
                string propKey = m_config.GetPropKey(ownerType, relationKey);
                Type revType = GetReverseType(relationKey, ownerType);
                rels.Add(owner, new List<Guid>());

                IDataClass res;

                if (m_config.GetMapping(propKey).Value.Field.DeclaringType == ownerType)
                {
                    object[] tmp = m_owner.GetObjects(revType,
                        m_config.GetMapping(propKey).Key.ColumnName + "=?",
                        m_config.GetMapping(propKey).Value.Field.GetValue(GetObjectByGuid(owner)));
                    if (tmp != null && tmp.Length == 1)
                        res = tmp[0] as IDataClass;
                    else
                        res = null;
                }
                else
                {
                    if (m_config.GetMapping(propKey).Key.Field.GetValue(GetObjectByGuid(owner)) == m_config.GetMapping(propKey).Key.GetDefaultValue(m_owner.Provider))
                        res = null;
                    else
                        res = m_owner.GetObjectById(revType, m_config.GetMapping(propKey).Key.Field.GetValue(GetObjectByGuid(owner))) as IDataClass;
                }

                if (res != null)
                {
                    rels[owner].Add(GetGuidForObject(res));

                    //Load the reverse items
                    if (m_config.IsCollection(revType, relationKey))
                        GetReferenceCollection(relationKey, res);
                    else
                        GetReferenceObject(relationKey, res);
                }

            }

            if (rels.ContainsKey(owner) && rels[owner].Count == 1)
                return GetObjectByGuid(rels[owner][0]);
            else
                return null;
        }

        public IDataClass GetReferenceObject(string relationKey, IDataClass owner)
        {
            return GetReferenceObject(relationKey, owner.GetType(), GetGuidForObject(owner));
        }

        public GenericListWrapper<T, IDataClass> GetReferenceCollection<T>(string propertyname, IDataClass owner) where T : IDataClass
        {
            return new GenericListWrapper<T, IDataClass>(GetReferenceCollection(propertyname, owner));
        }

        public IList<IDataClass> GetReferenceCollection(string relationKey, Type ownerType, Guid owner)
        {
            Dictionary<Guid, List<Guid>> rels = GetRelDict(relationKey, ownerType);
            if (!rels.ContainsKey(owner) && m_existsInDb.ContainsKey(owner) && m_existsInDb[owner])
            {
                string propKey = m_config.GetPropKey(ownerType, relationKey);
                rels.Add(owner, new List<Guid>());
                Type revType = GetReverseType(relationKey, ownerType);

                object[] tmp;

                if (m_config.GetMapping(propKey).Value.Field.DeclaringType == ownerType)
                {
                    tmp = m_owner.GetObjects(revType,
                        m_config.GetMapping(propKey).Key.ColumnName + "=?",
                        m_config.TypeConfiguration.UniqueValue(GetObjectByGuid(owner)));
                }
                else
                {
                    tmp = m_owner.GetObjects(revType,
                        m_config.GetMapping(propKey).Value.ColumnName + "=?",
                        m_config.TypeConfiguration.UniqueValue(GetObjectByGuid(owner)));
                }

                if (tmp != null)
                    foreach (IDataClass ic in tmp)
                    {
                        rels[owner].Add(GetGuidForObject(ic));
                        //Load the reverse items
                        if (m_config.IsCollection(revType, relationKey))
                            GetReferenceCollection(relationKey, ic);
                        else
                            GetReferenceObject(relationKey, ic);
                    }

            }

            if (!rels.ContainsKey(owner))
                rels.Add(owner, new List<Guid>());

            return new GuidProxyCollection(this, relationKey, rels[owner], ownerType, owner);
        }

        public IList<IDataClass> GetReferenceCollection(string relationKey, IDataClass owner)
        {
            return GetReferenceCollection(relationKey, owner.GetType(), GetGuidForObject(owner));
        }


        public Dictionary<string, List<Guid>> GetReferenceObjects(Type type, Guid item)
        {
            Dictionary<string, List<Guid>> list = new Dictionary<string, List<Guid>>();
            foreach (string s in m_references.Keys)
            {
                if (m_references[s].ContainsKey(item))
                {
                    List<Guid> cls = new List<Guid>();
                    foreach (Guid idc in m_references[s][item])
                        cls.Add(idc);
                    list[s] = cls;
                }
            }

            return list;
        }

        public void SetReferenceObjects(Type type, Guid item, Dictionary<string, List<Guid>> references)
        {
            foreach (string s in m_references.Keys)
                if (m_references[s].ContainsKey(item) && references.ContainsKey(s))
                {
                    string relationKey = m_config.GetRelationKey(type, s);
                    if (m_config.IsCollection(type, relationKey))
                    {
                        for (int i = 0; i < m_references[s][item].Count; i++)
                            if (!references[s].Contains(m_references[s][item][i]))
                            {
                                RemoveReferenceObjectInternal(relationKey, type, item, m_references[s][item][0], false);
                                i--;
                            }

                        /*while (m_references[s][item].Count > 0)
                            RemoveReferenceObjectInternal(relationKey, type, item, m_references[s][item][0], false);*/

                        foreach (Guid g in references[s])
                            AddReferenceObjectInternal(relationKey, type, item, g, false);
                        references.Remove(s);
                    }
                    else
                    {
                        if (references.ContainsKey(s) && references[s].Count == 1)
                            SetReferenceObjectInternal(relationKey, type, item, references[s][0], false);
                        else
                            SetReferenceObjectInternal(relationKey, type, item, Guid.Empty, false);

                        if (references.ContainsKey(s))
                            references.Remove(s);
                    }
                }

            foreach (string s in references.Keys)
            {
                string relationKey = m_config.GetRelationKey(type, s);
                if (m_config.IsCollection(type, relationKey))
                {
                    if (m_references.ContainsKey(s) && m_references[s].ContainsKey(item))
                        while (m_references[s][item].Count > 0)
                            RemoveReferenceObjectInternal(relationKey, type, item, m_references[s][item][0], false);

                    foreach (Guid g in references[s])
                        AddReferenceObjectInternal(relationKey, type, item, g, false);
                }
                else
                {
                    if (references[s].Count == 1)
                        SetReferenceObjectInternal(relationKey, type, item, references[s][0], false);
                    else
                        SetReferenceObjectInternal(relationKey, type, item, Guid.Empty, false);
                }
           }
        }

    }
}
